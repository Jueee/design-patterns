## 单例模式（Singleton）

### 意图
保证一个类仅有一个实例，并提供一个访问它的全局访问点。

### 动机
对一些类来说，只有一个实例是很重要的。但怎么样才能保证一个类只有一个实例并且这个实例易于被访问呢？

一个全局变量使得一个对象可以被访问，但它不能防止你实例化多个对象。

一个更好的办法是，让类自身负责保存它的唯一实例。这个类可以保证没有其他实例可以被创建（通过截取创建新对象的请求），并且它可以提供一个访问该实例的方法。这就是 Singleton 模式。

### 适用性
在下面的情况下可以使用 Singleton 模式：

- 当类只能有一个实例而且客户可以从一个众所周知的访问点访问它时。
- 当这个唯一实例应该是通过子类化可扩展的，并且客户应该无需更改代码就能使用一个扩展的实例时。

### 协作
客户只能通过 Singleton 的 Instance 操作访问一个Singleton的实例。

### 优点

Singleton模式有许多优点：

- **对唯一实例的受控访问**

  因为Singleton类封装它的唯一实例，所以它可以严格的控制客户怎样以及何时访问它。

- **缩小名空间**

  Singleton模式是对全局变量的一种改进。它避免了那些存储唯一实例的全局变量污染名空间。

- **允许对操作和表示的精化**

  Singleton类可以有子类，而且用这个扩展类的实例来配置一个应用是很容易的。你可以用你所需要的类的实例在运行时刻配置应用。

- **允许可变数目的实例**

  这个模式使得你易于改变你的想法，并允许Singleton类的多个实例。此外，你可以用相同的方法来控制应用所使用的实例的数目。只有允许访问Singleton实例的操作需要改变。

-	**比类操作更灵活**

### 示例一：懒汉模式（**线程不安全**）[示例](Pattern35_Singleton/src/main/java/com/jueee/example01/SingletonPattern.java)

通过提供一个静态的对象instance，利用private权限的构造方法和getInstance()方法来给予访问者一个单例。

缺点是，没有考虑到线程安全，可能存在多个访问者同时访问，并同时构造了多个对象的问题。

之所以叫做懒汉模式，主要是因为此种方法可以非常明显的 lazy loading。

### 示例二：线程安全的懒汉模式（**线程安全**）[示例](Pattern35_Singleton/src/main/java/com/jueee/example02/SingletonPattern.java)

由于并发其实是一种特殊情况，大多时候这个锁占用的额外资源都浪费了，这种打补丁方式写出来的结构效率很低。

### 示例三：饿汉模式（**线程安全**）[示例](Pattern35_Singleton/src/main/java/com/jueee/example03/SingletonPattern.java)

直接在运行这个类的时候进行一次loading，之后直接访问。

显然，这种方法没有起到lazy loading的效果，考虑到前面提到的和静态类的对比，这种方法只比静态类多了一个内存常驻而已。

### 示例四：静态类内部加载（**线程安全**）[示例](Pattern35_Singleton/src/main/java/com/jueee/example04/SingletonPattern.java)

使用内部类的好处是，静态内部类不会在单例加载时就加载，而是在调用getInstance()方法时才进行加载，达到了类似懒汉模式的效果，而这种方法又是线程安全的。

### 示例五：枚举方法（**线程安全**）[示例](Pattern35_Singleton/src/main/java/com/jueee/example05/SingletonPattern.java)

Effective Java作者 Josh Bloch 提倡的方式。解决了以下三个问题：

1. 自由串行化。
2. 保证只有一个实例。
3. 线程安全。

Josh Bloch 对这个方法的评价：

这种写法在功能上与共有域方法相近，但是它更简洁，无偿地提供了串行化机制，绝对防止对此实例化，即使是在面对复杂的串行化或者反射攻击的时候。虽然这中方法还没有广泛采用，但是单元素的枚举类型已经成为实现Singleton的最佳方法。

枚举单例这种方法问世以来，许多分析文章都称它是实现单例的最完美方法——写法超级简单，而且又能解决大部分的问题。

不过这种方法虽然很优秀，但是它仍然不是完美的——比如，在需要继承的场景，它就不适用了。

### 示例六：双重校验锁法（**通常线程安全，低概率不安全**）[示例](Pattern35_Singleton/src/main/java/com/jueee/example06/SingletonPattern.java)

在并发时，双重校验锁法会有怎样的情景：

1. 线程A访问getInstance()方法，因为单例还没有实例化，所以进入了锁定块。

2. 线程B访问getInstance()方法，因为单例还没有实例化，得以访问接下来代码块，而接下来代码块已经被线程1锁定。

3. 线程A进入下一判断，因为单例还没有实例化，所以进行单例实例化，成功实例化后退出代码块，解除锁定。

4. 线程B进入接下来代码块，锁定线程，进入下一判断，因为已经实例化，退出代码块，解除锁定。

5. 线程A获取到了单例实例并返回，线程B没有获取到单例并返回Null。

理论上双重校验锁法是线程安全的，并且，这种方法实现了lazyloading。

### 示例七：双重校验锁法（volatile版）[示例](Pattern35_Singleton/src/main/java/com/jueee/example07/SingletonPattern.java)

volatile关键字的一个作用是禁止指令重排，把instance声明为volatile之后，对它的写操作就会有一个内存屏障。

这样，在它的赋值完成之前，就不用会调用读操作。

注意：volatile阻止的不singleton = newSingleton()这句话内部[1-2-3]的指令重排，而是保证了在一个写操作（[1-2-3]）完成之前，不会调用读操作（if (instance == null)）。
也就彻底防止了6中的问题发生。

### 示例八：使用ThreadLocal实现单例模式（**线程安全**）[示例](Pattern35_Singleton/src/main/java/com/jueee/example08/SingletonPattern.java)

ThreadLocal会为每一个线程提供一个独立的变量副本，从而隔离了多个线程对数据的访问冲突。

对于多线程资源共享的问题，同步机制采用了“以时间换空间”的方式，而ThreadLocal采用了“以空间换时间”的方式。

前者仅提供一份变量，让不同的线程排队访问，而后者为每一个线程都提供了一份变量，因此可以同时访问而互不影响。

### 示例九：使用CAS锁实现（**线程安全**）[示例](Pattern35_Singleton/src/main/java/com/jueee/example09/SingletonPattern.java)

实现无锁（lock-free）的非阻塞算法有多种实现方法，其中 CAS（比较与交换，Compare and swap） 是一种有名的无锁算法。

CAS的语义是“**我认为V的值应该为A，如果是，那么将V的值更新为B，否则不修改并告诉V的值实际为多少**”。

CAS是一种乐观锁技术，当多个线程尝试使用CAS同时更新同一个变量时，只有其中一个线程能更新变量的值，而其它线程都失败，失败的线程并不会被挂起，而是被告知这次竞争中失败，并可以再次尝试。

CAS有3个操作数，内存值V，旧的预期值A，要修改的新值B。当且仅当预期值A和内存值V相同时，将内存值V修改为B，否则什么都不做。

CAS是以原子操作为基础，采用事务->提交->提交失败->重试这样特定编程手法的机制，它使得正在访问共享资源的线程不依赖于任何其它线程的调度和执行，并且能够在有限的步骤内完成。

