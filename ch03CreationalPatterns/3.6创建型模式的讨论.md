## 创建型模式的讨论

用一个系统创建的那些对象的类对系统进行参数化有两种常用方法：

- **生成创建对象的类的子类**

  这对应于使用 [工厂方法（Factory Method）](3.3工厂方法（FactoryMethod）.md) 模式。

  这种方法的主要缺点是，仅为了改变产品类，就可能需要创建一个新的子类。

  这样的改变可能是级联的（cascade）。

  例如，如果产品的创建者本身是由一个工厂方法创建的，那么你也必须重定义它的创建者。

- **对系统进行参数化的方法更多的依赖于对象复合**
  
  定义一个对象负责明确产品对 象的类，并将它作为该系统的参数。
  
  这是 [抽象工厂（AbstractFactory）](3.1抽象工厂（AbstractFactory）.md)、[生成器（Builder）](3.2生成器（Builder）.md) 和 [原型模式（Prototype）](3.4原型模式（Prototype）.md) 模式的关键特征。
  
  所有这三个模式都涉及到创建一个新的负责创建产品对象的“工厂对象”：
  
  - [抽象工厂（AbstractFactory）](3.1抽象工厂（AbstractFactory）.md)由这个工厂对象产生多个类的对象。
  - [生成器（Builder）](3.2生成器（Builder）.md)由这个工厂对象使用一个相对复杂的协议，逐步创建一个复杂产品。
  - [原型模式（Prototype）](3.4原型模式（Prototype）.md)由该工厂对象通过拷贝原型对象来创建产品对象。在这种情况下，因为原型负责返回产品对象，所以工厂对象和原型是同一个对象。

使用[抽象工厂（AbstractFactory）](3.1抽象工厂（AbstractFactory）.md)、[原型模式（Prototype）](3.4原型模式（Prototype）.md)或[生成器（Builder）](3.2生成器（Builder）.md)的设计甚至比使用[工厂方法（FactoryMethod）](3.3工厂方法（FactoryMethod）.md)的那些设计更灵活，但它们也更加复杂。

通常，设计以使用[工厂方法（FactoryMethod）](3.3工厂方法（FactoryMethod）.md)开始，并且当设计者发现需要更
大的灵活性时，设计便会向其他创建型模式演化。

当你在设计标准之间进行权衡的时候，了
解多个模式可以给你提供更多的选择余地。